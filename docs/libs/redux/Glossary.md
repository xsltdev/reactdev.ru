# Глоссарий

Это глоссарий основных терминов в Redux, наряду с их сигнатурами типа. Типы описаны при помощи [Flow notation](http://flowtype.org/docs/quick-reference.html).

## Состояние

```js
type State = any;
```

_Состояние_ (State) (также _дерево состояния_) — широкое понятие, но в Redux API это, как правило, отсылка к единственному состоянию, которое управляется стором (store) и возвращается [`getState()`](api/Store.md#getState). Оно представляет собой все состояние Redux-приложения, которое обычно является объектом с глубокой вложенностью.

Как правило, состояние верхнего уровня — это объект или какая-то другая коллекция вида ключ-значение, например Map, но технически это может быть любой тип. Вместе с тем, вам нужно стараться поддерживать состояние сериализуемым. Не кладите внутрь ничего, что потом не сможете легко превратить в JSON.

## Экшен

```js
type Action = Object;
```

_Экшен_ (Action) — это простой объект, который представляет намерение изменить состояние. Экшены — единственный путь получить данные в сторе. Любые данные, будь то события UI, коллбэки сетевых запросов или любые другие ресурсы как веб-сокеты, должны быть в итоге обработаны, как экшены.

Экшены обязаны иметь поле `type`, которое указывает тип производимого экшена. Типы также могут быть определены как константы и импортированы из другого модуля. Лучше использовать строки для `type`, чем [Символы](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol), потому что строки сериализуемы.

Вся остальная структура, кроме `type`, полностью на ваше усмотрение. Если вы заинтересованы, посмотрите [Flux Standard Action](https://github.com/acdlite/flux-standard-action) для рекомендаций как нужно создавать экшен.

Также смотрите [асинхронный экшен](#async-action) ниже.

## Редьюсер

```js
type Reducer<S, A> = (state: S, action: A) => S;
```

_Редьюсер_ (Reducer) (так же называемая, как _функция-редьюсер_) — это функция, которая принимает аккумулятор и значение и возвращает новый аккумулятор. Они используются для редуцирования (сокращения) коллекции значений в единственное значение.

Редьюсеры не уникальны для Redux — они являются фундаментальным понятием в функциональном программировании. Даже большинство нефункциональных языков, как JavaScript, имеют встроенное API для редуцирования. В JavaScript это [`Array.prototype.reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce).

В Redux, аккумулирумое значение — это объект состояния, а значения, которые должны быть аккумулированы — это экшены. Редьюсеры расчитывают новое состояние, учитывая предыдущее состояние и экшен. Они обязаны быть _чистыми функциями_ — функциями, которые возвращают одинаковый результат для переданных входных данных. Они также не должны иметь побочных эффектов (side-effects). Это то, что обеспечивает интересные возможности, такие как "горячая перезагрузка" (hot reloading) и путешествия во времени (time travel).

Редьюсеры являются наиболее важным понятием в Redux.

_Не размещайте вызовы API в редьюсерах._

## Функция-диспетчер {#dispatching-function}

```js
type BaseDispatch = (a: Action) => Action;
type Dispatch = (a: Action | AsyncAction) => any;
```

_Функция-диспетчер_ (Dispatching Function) - это функция, которая принимает экшен или [асинхронный экшен](#async-action) и далее может отправить или может не отправить один или несколько экшенов в стор.

Мы должны различать функцию-диспетчер в целом и базовую функцию [`dispatch`](api/Store.md#dispatch), предоставляемую экземпляром стора без всяких мидлваров (middlewares).

Базовая функция dispatch _всегда_ синхронно отправляет экшен в редьюсер вместе с предыдущим состоянием, возвращенным из стора, для вычисления нового состояния. Оно ожидает экшен в виде простых объектов, готовых для использования в редьюсере.

[Мидлвар](#middleware) оборачивает базовую функцию dispatch. Это позволяет функции-диспетчеру обрабатывать [асинхронные экшены](#async-action) в дополнение к обычным экшенам. Мидлвар может преобразовывать, задерживать, игнорировать или иным образом интерпретировать экшены или асинхронные экшены перед передачей их к следующему мидлвару. См. ниже для получения дополнительной информации.

## Генератор экшена

```js
type ActionCreator = (...args: any) => Action | AsyncAction;
```

_Генератор экшена_ (Action Creator) - это, совершенно очевидно, функция, которая создает экшен (action). Не следует путать эти два термина - еще раз, экшен - это структура данных, а генератор экшена - это фабрика, которая создает экшен (action).

Вызов генератора экшена только создает экшен, но не выполняет его. Вам нужно вызвать функцию стора [`dispatch`](api/Store.md#dispatch) которая на самом деле вызывает изменения. Иногда мы говорим _связанные генераторы экшенов_ имея ввиду функции, которые вызывают генератор экшена и сразу же отправляют его результат соответствующей части стора.

Если генератору экшена надо получить текущее состояние, выполнить вызов API или вызвать побочный эффект, как переход маршрутизации, это должно быть возвращено [асихронным экшеном (async action)](#async-action) вместо обычного экшена.

## Асинхронный экшен {#async-action}

```js
type AsyncAction = any;
```

_Асинхронный экшен_ (async action) - это значение, которое передается в вызывающую функцию (dispatching function), но пока не готово для редьюсера. Оно будет преобразовано при помощи [мидлвара](#middleware) в экшен или набор экшенов перед отправкой в базовую функцию [`dispatch()`](api/Store.md#dispatch). Асинхронные экшены могут иметь различные типы в зависимости от используемых мидлваров. Они часто являются асихронными примитивами, как промисы (Promise) или thunk, которые не передаются в редьюсер немедленно, а выполняют экшен, только когда операция завершена.

## Мидлвар {#middleware}

```js
type MiddlewareAPI = {
    dispatch: Dispatch,
    getState: () => State,
};
type Middleware = (
    api: MiddlewareAPI
) => (next: Dispatch) => Dispatch;
```

_Мидлвар_ (Middleware) — это функция высшего порядка, которая создает [функцию-диспетчер (dispatch function)](#dispatching-function), возвращающую новую функцию-диспетчер. Она часто возвращает [асинхронный экшен](#async-action) в экшен.

Мидлвары компонуемы с помощью функции композиции - это полезно для регистрации экшенов, выполнения побочных действий (side effects), таких как, маршрутизация или превращения асинхронного вызова API в серию синхронных экшенов.

См. [`applyMiddleware(...middlewares)`](./api/applyMiddleware.md) для более детальной информации по мидлварам.

## Стор

```js
type Store = {
  dispatch: Dispatch
  getState: () => State
  subscribe: (listener: () => void) => () => void
  replaceReducer: (reducer: Reducer) => void
}
```

_Стор_ (Store) — это объект, который хранит дерево состояний приложения.
В приложении должно быть только один стор, так построение происходит на уровне преобразователя (reducer).

-   [`dispatch(action)`](api/Store.md#dispatch) базовая функция отправки (dispatch), описанная выше.
-   [`getState()`](api/Store.md#getState) возвращает текущее состояние стора.
-   [`subscribe(listener)`](api/Store.md#subscribe) регистрирует функцию, которая будет вызвана при изменении состояния.
-   [`replaceReducer(nextReducer)`](api/Store.md#replaceReducer) может быть использован для реализации горячей перезагрузки (hot reload) и разделения кода. Скорее всего Вы не будете использовать ee.

См. [store API reference](api/Store.md#dispatch) для получения дополнительной информации.

## Генератор стора

```js
type StoreCreator = (
    reducer: Reducer,
    initialState: ?State
) => Store;
```

_Генератор стора_ (Store creator) — это функция, которая создает Redux-стор. Как и в случае с отправляющей функцией, мы должны различать базовый генератор стора, [`createStore(reducer, initialState)`](api/createStore.md) экспортирумый из Redux, от генератора стора, возвращаемого из расширителей стора (store enhancers).

## Расширитель стора

```js
type StoreEnhancer = (next: StoreCreator) => StoreCreator;
```

_Расширитель стора_ (Store enhancer) — это функция высшего порядка, которая создает генератор стора, возвращающий новый, расширенный генератор стора. Это похоже на мидлвар тем, что позволяет вам изменять интерфейс в композиционном стиле.

Расширители стора аналогичны понятию - "компоненты высшего порядка" в React, которые также иногда называются "усилителями компонент".

Поскольку стора является не инстансом, а скорее объектом-коллекцией функций, то копии могут быть запросто созданы и модифицированы, без изменения оригинального стора. Пример в описании [`compose`](api/compose.md) демонстрирует это.

Скорее всего, вы никогда не будете писать расширитель стора, но вы можете использовать один предоставленный [developer tools](https://github.com/gaearon/redux-devtools). Это то, что делает "путешествие во времени" (time travel) возможным без информирования приложения, о том, что происходит. Занятно, что [реализация Redux мидлваров](api/applyMiddleware.md) сама по себе является расширителем стора.
